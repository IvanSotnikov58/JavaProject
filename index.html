<!doctype html>
<html lang="ru">
<head>
    <meta charset="utf-8" />
    <title>Hearthclone</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
        :root{
            --bg:#1c1f26;
            --panel:#282c34;
            --muted:#9aa0a6;
            --accent:#ffcc33;
            --accent-2:#ffdb55;
            --card-bg:#23252b;
            --shadow: 0 8px 24px rgba(0,0,0,0.6);
        }
        html,body{height:100%;margin:0;font-family:system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:#fff}
        .container{
            max-width:1100px;
            margin:24px auto;
            padding:18px;
            position:relative; /* важно для абсолютного позиционирования колоды */
        }

        header{display:flex;align-items:flex-start;gap:18px;justify-content:space-between}
        .title { display:flex; flex-direction:column; gap:6px; }
        h1{margin:0;font-size:34px;letter-spacing:1px}
        .subtitle{color:var(--muted);font-size:14px}

        /* right account box */
        .account {
            background:var(--panel);
            padding:12px 14px;
            border-radius:10px;
            box-shadow:var(--shadow);
            text-align:right;
            min-width:220px;
        }
        .account b{display:block;font-size:16px}
        .statline{margin-top:8px;font-size:13px;color:var(--muted)}
        .logout{margin-top:10px;padding:6px 10px;border-radius:8px;border:none;background:#3a3f46;color:#fff;cursor:pointer}

        /* layout - основа */
        /* .layout теперь просто оболочка, а .left позиционируется абсолютно */
        .layout{ position:relative; margin-top:28px; min-height:200px; }

        /* левый блок (колода) - абсолютный, не ломает центр */
        .left {
            position: absolute;
            left: -60px;      /* <- сдвиг влево, можешь увеличить/уменьшить */
            top: 12px;        /* вертикальное выравнивание относительно layout */
            width:260px;
            z-index: 5;
        }

        /* основной центр - остаётся по центру контейнера */
        .main {
            margin: 0 auto;
            max-width: 680px;  /* центрированная колонка */
            text-align:center;
        }

        .deck-box{
            background:var(--panel);
            padding:12px;border-radius:10px;box-shadow:var(--shadow);text-align:left;
        }
        .deck-box h3{margin:0 0 8px 0}
        .deck-item{display:flex;justify-content:space-between;padding:6px 8px;border-radius:6px;background:var(--card-bg);margin-bottom:8px;font-size:14px}
        .deck-empty{color:var(--muted);font-size:14px}

        .play-btn {
            display: inline-block;
            margin-top:8px;
            padding:20px 60px;
            font-size:32px;
            font-weight:700;
            background:var(--accent);
            color:#111;
            border-radius:10px;
            text-decoration:none;
            transition:all .12s ease;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
        }
        .play-btn:hover{transform:translateY(-4px); background:var(--accent-2)}

        .menu-block{margin-top:36px;display:flex;flex-direction:column;gap:12px;align-items:center}
        .menu-btn {
            display:block;width:260px;padding:12px 0;border-radius:8px;background:var(--card-bg);color:#fff;text-decoration:none;font-size:16px;
            border:1px solid rgba(255,255,255,0.04);
        }
        .menu-btn:hover{background:#2b2f36}

        .note{margin-top:8px;color:var(--muted);font-size:13px}

        /* Responsive: на очень узких экранах нужно, чтобы левый блок не мешал центру */
        @media (max-width:820px){
            .left { position: static; left: auto; top: auto; width:100%; margin-bottom:14px; }
            .main { max-width: 100%; padding: 0 10px; }
            .container{padding-left:12px;padding-right:12px;}
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        <div class="title">
            <h1>Hearthclone</h1>
            <div class="subtitle">Прототип карточной игры. Жми «Играть», если хочешь тестить</div>
        </div>

        <div class="account" id="accountBox">
            <div id="accountName">Не вошёл</div>
            <div class="statline" id="accountStats">Рейтинг - - · Победы - · Поражения -</div>
            <button class="logout" id="btnLogout" style="display:none">Выйти</button>
        </div>
    </header>

    <div class="layout">
        <div class="left">
            <div class="deck-box">
                <h3>Текущая колода</h3>
                <div id="deckListArea">
                    <div class="deck-empty">Колода не выбрана. Зайди в <a href="/deckbuilder.html" style="color:var(--accent)">Сборщик</a></div>
                </div>
            </div>
        </div>

        <div class="main">
            <a class="play-btn" id="btnPlay" href="/match.html">Играть</a>

            <div class="menu-block">
                <a class="menu-btn" href="/deckbuilder.html">Сборщик колоды</a>
                <a class="menu-btn" href="/cards.html">Просмотреть карты</a>
                <a class="menu-btn" href="/login.html">Логин / Регистрация</a>
                <a class="menu-btn" href="/arena.html">ТЕСТ ПОТОМ УДАЛИТЬ</a>
            </div>

            <div class="note">Если данные аккаунта не отображаются, убедись, что ты вошёл через страницу логина.</div>
        </div>
    </div>
</div>

<!-- Твой прежний JS без изменений - вставь сюда тот же код, что и был (загрузка user/deck, logout и т.п.) -->
<script>
/*
  Логика:
  - Получаем userId из localStorage (hc_userId). Если нет - показываем ссылку на логин.
  - Запрашиваем информацию о юзере: сначала GET /users/{id}, если 404/ошибка - fallback GET /users и поиск по id.
  - Запрашиваем колоды: GET /decks/player/{id}. Берём первую колоду (если есть) и показываем список карт: name + cost.
  - Кнопка logout чистит localStorage.
  - Вставлены защитные блоки, чтобы UI не ломался при разных форматах ответов.
*/

async function fetchJsonSafe(url) {
  try {
    const r = await fetch(url);
    if (!r.ok) return { ok:false, status: r.status, body: await (r.text().catch(()=>null)) };
    const obj = await r.json().catch(()=>null);
    return { ok:true, status: r.status, body: obj };
  } catch (e) {
    return { ok:false, status: 0, body: null, error: e };
  }
}

async function getUserInfo(userId) {
  if (!userId) return null;
  // try /users/{id}
  const single = await fetchJsonSafe(`/users/${userId}`);
  if (single.ok && single.body) return single.body;

  // fallback: get all users then find by id
  const all = await fetchJsonSafe('/users');
  if (all.ok && Array.isArray(all.body)) {
    const found = all.body.find(u => String(u.id) === String(userId));
    if (found) return found;
  }

  return null;
}

async function getDeckForUser(userId) {
  if (!userId) return null;
  const res = await fetchJsonSafe(`/decks/player/${userId}`);
  if (!res.ok) return null;
  const body = res.body;
  if (Array.isArray(body) && body.length>0) {
    return body[body.length-1]; // берём последнюю созданную колоду
  }
  if (body && body.id) return body;
  if (body && body.decks && Array.isArray(body.decks) && body.decks.length>0) return body.decks[body.decks.length-1];
  return null;
}


function renderAccount(user) {
  const nameEl = document.getElementById('accountName');
  const statsEl = document.getElementById('accountStats');
  const logoutBtn = document.getElementById('btnLogout');
  if (!user) {
    nameEl.textContent = 'Не вошёл';
    statsEl.textContent = 'Рейтинг - - · Победы - · Поражения -';
    logoutBtn.style.display = 'none';
    return;
  }
  const displayName = user.name || user.username || ('user#' + (user.id || '-'));
  nameEl.innerHTML = `<b>${escapeHtml(displayName)}</b>`;
  const rating = (typeof user.rating !== 'undefined') ? user.rating : '-';
  const wins = (typeof user.wins !== 'undefined') ? user.wins : '-';
  const losses = (typeof user.losses !== 'undefined') ? user.losses : '-';
  statsEl.textContent = `Рейтинг ${rating} · Победы ${wins} · Поражения ${losses}`;
  logoutBtn.style.display = 'inline-block';
  logoutBtn.onclick = () => {
    localStorage.removeItem('hc_userId');
    localStorage.removeItem('hc_userName');
    // обновить UI - лучше просто перезагрузить
    location.reload();
  };
}

function escapeHtml(s){
  if(!s && s!==0) return '';
  return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
}

function renderDeckCards(deck) {
  const area = document.getElementById('deckListArea');
  area.innerHTML = '';
  if (!deck) {
    area.innerHTML = `<div class="deck-empty">Колода не выбрана. Зайди в <a href="/deckbuilder.html" style="color:var(--accent)">Сборщик</a></div>`;
    return;
  }
  const cards = deck.cards || deck.cardList || deck.cardsList || [];
  if (!Array.isArray(cards) || cards.length===0) {
    area.innerHTML = `<div class="deck-empty">Колода пуста</div>`;
    return;
  }
  // show only name and cost
  const list = document.createElement('div');
  cards.forEach(c => {
    const name = c?.name || c?.Name || 'unnamed';
    const cost = (typeof c?.cost !== 'undefined') ? c.cost : (c?.Cost ?? '-');
    const item = document.createElement('div');
    item.className = 'deck-item';
    item.innerHTML = `<span>${escapeHtml(name)}</span><span style="color:var(--muted)">cost ${escapeHtml(cost)}</span>`;
    list.appendChild(item);
  });
  area.appendChild(list);
}

(async function init(){
  const storedId = localStorage.getItem('hc_userId');
  const storedName = localStorage.getItem('hc_userName');
  // try to get full user
  const user = await getUserInfo(storedId);
  // if not found, but we have storedName, show that as minimal info
  if (!user && storedName) {
    renderAccount({ id: storedId, name: storedName });
  } else {
    renderAccount(user);
  }

  // load deck
  const deck = await getDeckForUser(storedId);
  renderDeckCards(deck);
})();
</script>
</body>
</html>





</body>
</html>
